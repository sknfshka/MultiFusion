#ifndef __FIGURE_TOOL_INTERFACE_H__
#define __FIGURE_TOOL_INTERFACE_H__

#include <QPolygonF>
#include <QObject>
#include <QString>
#include <QVector>
#include <QIcon>

/**
*	@file figuretoolinterface.h В данном файле описан интерфейс, который должен реализовывать
*		любой плагин, отвечающий за некоторый инструмент рисования.
*/

/**
*	@example LineTool
*
*	Заголовочный файл инструмента "Линия" :)
*
*	@code
*
*	#ifndef __LINE_H__
*	#define __LINE_H__
*
*	#include "Plugin.h"	//	Это нужно для класса plugin::PluginsManager,
*						//указатель на который мы получаем в конструкторе.
*						//Да и, в целом, мы же плагин пишем :)
*	#include "figuretoolinterface.h" //Тут описан интерфейс, который мы реализуем.
*
*	//	Наш класс плагина. Мы хотим, что бы наш инструмент отображался примерно вторым на панели
*	//инструментов, потому начинаем имя класса с символа "B" - он второй в английском алфавите.
*	class B_Line:public QObject, public FigureToolInterface
*	{
*		Q_OBJECT
*		Q_INTERFACES( FigureToolInterface )	//Сообщаем всем, что мы реализуем данный интерфейс.
*
*		public:
*			virtual QIcon icon()
*			{
*				//Эту иконку мы берём из ресурсов, но могли бы и откуда угодно брать.
*				return QIcon( ":/line/images/line.png" );
*			}
*
*			virtual CreateStyle createStyle() const
*			{
*				return createAndResize;	//Линия после создания должна быть протянута.
*			}
*
*			virtual FiguresInfo figure() const
*			{
*				//Наша фигура состоит из одного сегмента.
*				FigureInfo info;
*
*				info.closed = false;	//Она не замкнута
*				info.spline = false;	//Точки соединены простыми линиями
*				//Их координаты таковы (просто диагональ через прямоугольник размерами 1:1)
*				info.points << QPointF( 0.0, 0.0 ) << QPointF( 1.0, 1.0 );
*
*				//Имя фигуры у нас будет такое.
*				info.name = figureName();
*
*				//Возвращаем наш сегмент в том виде, что бы его поняла программа.
*				return ( FiguresInfo() << info );
*			}
*
*			virtual QString description() const
*			{
*				//Трудно что-то другое придумать к описанию данного инструмента...
*				return tr( "Simple line" );
*			}
*
*			virtual QString figureName() const
*			{
*				//Имя новосозданной фигуры. Данный метод никогда не будет
*				//использован извне класса - наша фигура состоит из одного сегмента.
*				return tr( "Line" );
*			}
*
*			//Тут мы ничего делать не хотим, но метод определить обязаны.
*			virtual void toolSelected()
*			{
*			}
*
*					//	Конструктор. Принимает в параметрах, как и любой другой плагин,
*					//указатель на менеджер плагинов, который данный плагин загружает.
*					B_Line( const plugin::PluginsManager *manager )
*					{
*						//При первом создании плагина инициализируем ресурсы - нет смысла их
*						//инициализировать каждый раз - они статические.
*						if( !resourcesInited )
*						{
*							Q_INIT_RESOURCE( line );
*							resourcesInited = true;
*						}
*
*					}
*
*			//Деструктор. В нашем случае - пустой. Но без него ничего не скомпилируется.
*			virtual ~B_Line()
*			{
*			}
*
*		private:
*			//Флаг того, что мы уже загрузили ресурсы.
*			static bool resourcesInited;
*	};
*
*	#endif // __LINE_H__
*	@endcode
*
*	Ну, и то, что необходимо дописать в файле реализации данного плагина:
*
*	@code
*
*	#include "line.h" //Заголовочный файл с описанием нашего плагина (см. чуть выше).
*
*	bool B_Line::resourcesInited = false;	//Определение статического флага загрузки ресурсов и
*					//установка его начального значения - изначально ресурсы не загруженны.
*
*	//И экспорт плагина из динамической библиотеки.
*	EXPORT_PLUGIN( B_Line, FigureToolInterface )
*
*	@endcode
*
*		Всё. Осталось только скомпоновать ресурсы, откомпилировать плагин и положить в папку
*	с плагинами к программе. После её запуска плагин будет загружен и пользователь с его
*	помощью сможет рисовать линии.
*/
/**
*		Интерфейс, который должен реализовывать
*	любой плагин, отвечающий за некоторый инструмент рисования.
*
*	@warning Порядок загрузки и отображения инструментов на панели инструментов определяется
*		именем класса плагина - плагины перед отображением сортируются по алфавиту по имени класса.
*/
class FigureToolInterface: public QObject
{
	public:
		/**
		 * Позволяет получить QWidget, представляющий фигуру в интерфейсе приложения.
		 * Если фигура не имеет своего виджета в интерфейсе приложения, необходимо вернуть NULL.
		 */
		virtual QWidget* getWidget() = 0;

		/**
		*		Данное перечисление отвечает за стиль создания новой фигуры при использовании
		*	вашего плагина, реализующего инструмент.
		*/
		enum CreateStyle
		{
			paint,			/** << после создания пользователю будет предоставленна возможность
									продолжить вашу фигуру простым рисованием.
									Это необходимо, например, инструменту "карандаш" */

			createAndResize,	/** << Обычный режим создания, при котором при щелчке мышью создаётся
									уже готовый обьект, а потом он просто растягивается */
		    paintAfterRelease
							
		};

		/**
		*	Структура, описывающая один из фрагментов фигуры, которая будет созданна.
		*/
		struct FigureInfo
		{
			bool closed;		/** << определяет замкнутость фигуры */
			bool spline;		/** << определят, будет ли фигура соединена сплайнами
										или простыми линиями */

			QPolygonF points;	/** << точки, из которых состоит фигура. Они должны находится либо в
										интервале от [0..1] по обеим координатам, либо нижний
										правый угол фигуры должен иметь координаты [0, 0] */

			QString name;		/** << Начальное имя новосозданного фрагмента */
		};

		/**
		*		Тип, определяющий полностью новую фигуру, которая будет созданна.
		*	Фигура должна состоять как минимум из одного фрагмента, но может и из нескольких -
		*	для каждого из них будет создан свой обьект и они будут сгруппированы. Если фрагмент
		*	всего один - то только он и создасться. Никакой группировки при этом не произойдёт.
		*/
		typedef QVector< FigureInfo > FiguresInfo;

		/**
		*	Должен возвращать иконку данного инструмента.
		*/
		virtual QIcon icon() = 0;

		/**
		*		Должен возвращать тот стиль создания, который более всего подходит для
		*	данного инструмента.
		*/
		virtual CreateStyle createStyle() const = 0;

		/**
		*		Должно возвращаться полное описание фигуры, которая будет создаваться
		*	с помощью данного инструмента.
		*/
		virtual FiguresInfo figure() const = 0;

		/**
		*		Краткое описание данного инструмента. Может быть отображено впоследствии
		*	в tooltip-е кнопки, отвечающей за него. Или ещё где.
		*/
		virtual QString description() const = 0;

		/**
		*		Начальное имя всей фигуры целиком. Будет использованно только в том случае, если
		*	фигура имеет несколько фрагментов в своём составе.
		*/
		virtual QString figureName() const = 0;

		/**
		*		Данный метод вызывается при выборе пользователем данного инструмента. Внутри него
		*	может происходит дополнительная инициализация инструмента, можно вызвать некоторый
		*	диалог настроек, если он необходим.
		*/
		virtual void toolSelected() = 0;

				/**
				*	Конструктор
				*/
				FigureToolInterface()
				{
				}

		/**
		*	Деструктор.
		*/
		virtual	~FigureToolInterface()
		{
		}
};

Q_DECLARE_INTERFACE( FigureToolInterface, "com.Tailer.MultiFusion.FigureToolInterface/1.0" )

/**
*	Приводит указатель на любой обьект к указателью на интерфейс FigureToolInterface.
*
*	@return Приведённый указатель или 0, если произошла ошибка.
*/

template < class T > inline FigureToolInterface* FIGURETOOL( T *o )
{
	return qobject_cast< FigureToolInterface* >( o );
}


#endif /* __FIGURE_TOOL_INTERFACE_H__ */
